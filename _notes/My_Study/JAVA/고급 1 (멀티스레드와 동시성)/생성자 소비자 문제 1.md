생성자 소비자의 synchronized 메서드 안에서 임계영역안에 락을 반납하지않고 대기한다면
다른 스레드의 상태는 모두 Blooked 상태가 된다. 그래서 대기가 필요한 경우에는 락을 반납해야하는데 Object의 wait(), notify를 통해서 반납할 수 있다.

### Object.wait()
- 현재 스레드가 가진 락을 반납하고 대기한다.
### Object.notify()
- 대기 중인 스레드 중 하나를 깨운다.
### Object.notify()
- 대기 중인 모든 스레드를 깨운다.

> [!NOTE]
> 현재 스레드가 synchronized 블럭이나 메서에서만 호출 가능

### 스레드 대기 집합 work set
- wait로 인해 대기 상태 중인 스레드들을 관리하는 집합 
- notify가 대기 집합에 알린다. 하지만 누구를 깨우는지 모른다.
- 그래서 같은 생산자가 생산자를 깨울수도 소비자가 같은 소비자를 깨울수 있어 
	비효율 적이다. 즉 같은 종류의 스레드를 깨울 때 비효율이 발생한다.

### 스레드 기아 
- 같은 종류의 스레드를 깨울수 있다 계속 반복해서 깨워서 다른 종류의 스레드가 아주 나중에 깨어날 수 있다. 이처럼 실행 순서를 계속 얻지 못해서 실행되지 않는 상황을 스레드 기아 상태라고 한다.

> notifyAll()로 모든 스레드를 다 깨워서 스레드 기아를 막을 수 있지만 비효율을 막지는 못한다.






