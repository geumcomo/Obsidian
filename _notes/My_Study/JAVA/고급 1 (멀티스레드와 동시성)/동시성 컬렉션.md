==java.util  패키지에 소속되어 있는 컬렉션 프레임워크는 원자적 연산을 제공할까?==
==예를들어 하나의 ArrayList 인스턴스에 여러 스레드가 동시에 접근해도 괜찮을까?==

### 스레드 세이프

- 여러 스레드가 동시에 접근해도 괜찮은 경우

> [!NOTE]
> 
> 우리가 일반적으로 자주 사용하는 ArrayList, LinkedList, HashSet, HashMap 등 수 많은 자료 구조들은 예를 들어서 데이터를 추가하는 add()의 메서드를 보면 size++ 같은 원자적 연산이 아니기 때문에 수행할 수 없다 그래서 컬렉션들은 절대로 스레드 세이프 하지 않다!

## 해결방법

1.  메서드에 sync 를 추가한다. (복사한 컬렉션 코드에 sync를 추가해야하는 불편함)
2.  프록시 도입

## 프록시

- 우리말로 대리자, 대신 처리해주는 자라는 뜻
- 프록시가 대신 동기화 기능을 처리해주는 것이다.
- 빈 껍데기라고 생각하면 쉽다.
### 목적
- 접근제어
- 성능향상
- 부가 기능 제공: 실제 객체의 추가적인 기능 (로깅, 인증 , 동기화) 투명하게 제공(거의 비슷한)

## 자바 동시성 컬렉션

sync, Lock, CAS 등 모든 방식은 정도 차이가 있지만 성능과 트레이드 오프가 있다. 
결국 동기화를 사용하지 않는 것이 빠르다.

자바의 Vector라는 클래스가 있는데 의미없는  sync로 인해 성능이 느려진다. (하위호환으로 남겨둠)

앞서 배운 sync대신 프록시를 만드는 방법이 있다.

### Collection.synschronized()

- sync 를 추가하는 프록시 역할을 한다.
- 컬렉션의 모든 프레임워크를 다양한 동기화 프록시를 만들어 낼 수있다.

## 단점

1. 동기화 오버헤드 발생. (호출시마다 동기화 비용 추가)

2. 전체 컬렉션에 대해 동기화 이루어지기 때문에, 잠금범위가 넓어지고, 이는 잠금 경합 증가, 병렬 처리 효율성 저하 (다른 스레드들이 대기해야하는 상황이 빈번)

3. 정교한 동기화 불가능 (특정 부분이나 메서드에 대해 선택적 동기화 적용이 어려움)

이런 단점을 보완하기 위해  Java.util.concurrent 동시성 컬렉션을 제공한다.

